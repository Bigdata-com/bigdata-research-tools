# -*- coding: utf-8 -*-
"""Bug create_data_ranges.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s3PrlfuwVR6YxPDsqlsvz5Z6L1us4SZk
"""


"""## Import Required Libraries"""

import os
import time
from datetime import datetime, date
from typing import List, Dict, Any, Optional, Tuple
import pandas as pd

from bigdata_client import Bigdata
from bigdata_client.models.search import DocumentType, SortBy
from bigdata_research_tools.search.search import run_search

from bigdata_research_tools.tracing import Trace, TraceEventNames, send_trace
from bigdata_research_tools.client import bigdata_connection


print("âœ… Credentials loaded from Colab secrets")

bigdata = Bigdata()

# Themes
news_search_mapping = [
    "Past Misconduct of Management",
    "Inconsistencies in Statements",
]

board_themes = [
    "Board member appointments and new director appointments",
    "Board member resignations and director departures",
]

# Time Ranges
date_periods = [
    ("2023-01-01", "2023-02-01"),
]

# Person Details
persons_dict = {
    'Emmanuel Faber': {
        'id': '6D9368',
        'variations': [
            'Emmanuel Faber',    # First Name + Last Name
            'E. Faber',         # Initial + Last Name
            'Faber, Emmanuel',   # Last Name + comma + First Name
            'Emmanuel F.'         # First Name + Initial
        ]
    }
}

#Company Details
company_name = 'Danone S.A.'
company_data = {'id': '3E149C'}

from bigdata_client.query import Keyword, Entity, Similarity, Source, Any as QueryAny
def parse_date(date_input):
    """Convert various date formats to date object"""
    from datetime import datetime, date

    if isinstance(date_input, str):
        return datetime.strptime(date_input, "%Y-%m-%d").date()
    elif isinstance(date_input, datetime):
        return date_input.date()
    elif isinstance(date_input, date):
        return date_input
    else:
        raise ValueError(f"Unsupported date format: {type(date_input)}")
def build_queries_for_monitoring(
    date_periods: List[Tuple],
    persons: Dict[str, Dict[str, Any]],
    company: Dict[str, str],
    news_search_mapping: List[str],
    board_themes: List[str],
    search_mode: str = "strict",
    sources: Optional[Dict[str, str]] = None,
    use_source_filter: bool = True
) -> Tuple[List, List, List]:
    """
    Build base queries for board/management monitoring (without date multiplication).

    Parameters:
        date_periods: List of (start_date, end_date) tuples
        persons: Dictionary of persons with their name variations
        company: Dictionary containing company info with 'id' field
        news_search_mapping: List of management themes
        board_themes: List of board themes
        search_mode: "strict", "relaxed", or "relaxed_post"
        sources: Dictionary of source names to IDs (optional)
        use_source_filter: Whether to apply source filtering

    Returns:
        Tuple of (base_queries, date_ranges_list, query_details_template)
    """
    base_queries = []
    query_details_template = []

    # Generate source filter if requested
    source_filter = None
    if use_source_filter and sources:
        source_filter = create_source_filter(list(sources.values()))
        print(f"Using source filter with {len(sources)} trusted sources")
    else:
        print("Using all available news sources (no source filtering)")

    # Build date ranges list directly from tuples as ISO strings for JSON compatibility
    date_ranges_list = []
    for start, end in date_periods:
        start_date = parse_date(start)
        end_date = parse_date(end)
        # Convert to ISO string tuples to avoid JSON serialization issues in tracing
        start_iso = datetime.combine(start_date, datetime.min.time()).isoformat()
        end_iso = datetime.combine(end_date, datetime.min.time()).isoformat()
        date_ranges_list.append((start_iso, end_iso))

    # Build base queries
    for person_name, data in persons.items():
        variations = data.get("variations", [person_name])
        person_component = QueryAny([Keyword(var) for var in variations])

        # In strict mode, require company entity
        if search_mode == "strict":
            company_component = Entity(company['id'])
            combined_component = company_component & person_component
        else:
            combined_component = person_component

        # Build queries for management themes
        for theme in news_search_mapping:
            if source_filter:
                q = combined_component & Similarity(theme) & source_filter
            else:
                q = combined_component & Similarity(theme)
            base_queries.append(q)
            query_details_template.append({
                "person": person_name,
                "theme": theme,
                "theme_type": "management"
            })

        # Build queries for board themes
        for theme in board_themes:
            if source_filter:
                q = combined_component & Similarity(theme) & source_filter
            else:
                q = combined_component & Similarity(theme)
            base_queries.append(q)
            query_details_template.append({
                "person": person_name,
                "theme": theme,
                "theme_type": "board"
            })

    print(f"Prepared {len(base_queries)} base queries and {len(date_ranges_list)} date ranges")
    return base_queries, date_ranges_list, query_details_template

"""# NO ERROR (differnt function used to avoid the error)"""

from bigdata_research_tools.search.query_builder import  create_date_ranges

queries, date_ranges, query_details = build_queries_for_monitoring(
    date_periods=date_periods[:1],
    persons=persons_dict,
    company=company_data,
    news_search_mapping=news_search_mapping,
    board_themes=board_themes,
    search_mode='relaxed',
    use_source_filter=False
)
print(date_ranges)
print(type(date_ranges))
print(date_ranges[0])
print(type(date_ranges[0]))
print(type(date_ranges[0][0]))

"""# ERROR"""

date_ranges_from_create_date_ranges = create_date_ranges("2023-01-01", "2023-02-01", "W")

print(date_ranges_from_create_date_ranges)
print(type(date_ranges_from_create_date_ranges))
print(date_ranges_from_create_date_ranges[0])
print(type(date_ranges_from_create_date_ranges[0]))

print(queries)
search_results = run_search(
  queries=queries,
  date_ranges=date_ranges_from_create_date_ranges,
  sortby=SortBy.RELEVANCE,
  scope=DocumentType.NEWS,
  limit=100,
  only_results=True,
  rerank_threshold=None,
  )

